/**
 GPII Flow Manager Utilities.

 Copyright 2012 OCAD University

 Licensed under the New BSD license. You may not use this file except in
 compliance with this License.

 You may obtain a copy of the License at
 https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion");
    var gpii = fluid.registerNamespace("gpii");
    var kettle = fluid.registerNamespace("kettle");
    var util = require("util");
    fluid.registerNamespace("gpii.request.flowManager");

    gpii.request.flowManager.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.request.flowManager.getPreferences = function (preferencesDataSource, event, token) {
        fluid.log("gpii.request.flowManager.getPreferences called - fetching preferences");
        preferencesDataSource.get({
            token: token
        }, gpii.request.flowManager.logAndNotify("Fetched user preferences: ", event,
            function getPreferences(data) {
                return data.preferences || data;
            }));
    };

    gpii.request.flowManager.getDevice = function (deviceReporterDataSource, event) {
        fluid.log("gpii.request.flowManager.getDevice called - fetching device info");
        deviceReporterDataSource.get(null, gpii.request.flowManager.logAndNotify(
            "Fetched device reporter data: ", event));
    };

    /*
     * Asynchronous function which makes a get call to the solutions registry (1st parameter) to
     * retrieve the solutions registry matching what is passed in the `device` parameter.
     * This is appended to the matchmaker payload (mmpayload) parameter, which in turn is passed
     * as parameter in the event fired.
     *
     * @solutionsRegistry (Object) - a solutions registry data source
     * @mmpayload (Object) - the matchmaker payload on which to attach the retrieved solution object
     * @device (Object) - output from a device reporter. Used to filter solutions registry entries
     * @event (Object) - Event to be fired when the solutionsRegistry entry has been retrieved
     *
     * @return (undefined) - function is asynchronous and doesn't return anything. Instead the event
     *      is fired with the modified mmpayload.
     */
    gpii.request.flowManager.getSolutions = function (solutionsRegistryDataSource, device, event) {
        var os = fluid.get(device, "OS.id"),
            version = fluid.get(device, "OS.version");
        solutionsRegistryDataSource.get({
            os: os,
            version: version
        }, function (solutions) {
            var solutionsRegistry = gpii.matchMakerFramework.filterSolutions(solutions, device);
            fluid.log("Fetched solutions registry: "+JSON.stringify(solutionsRegistry, null, 4));
            event.fire(solutionsRegistry);
        });
    };

    gpii.request.flowManager.runMatchMakerFramework = function (that, matchMakerFramework, preferences, device, solutionsRegistry) {
        matchMakerFramework.preProcess(that.userToken, preferences, device, solutionsRegistry);
    };

    // TODO: This component is poorly named
    fluid.defaults("gpii.request.flowManager.token", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        invokers: {
            getPreferences: {
                funcName: "gpii.request.flowManager.getPreferences",
                args: ["{flowManager}.preferencesDataSource", "{that}.events.onPreferences", "{that}.userToken"]
            },
            onMatch: { //TODO KASPER should this be deleted?
                funcName: "gpii.request.flowManager.onMatch",
                args: [ "{that}", "{gpii.matchMakerFramework}",  "{that}.events.onMatch", "{arguments}.0", "{arguments}.1"]
                                                               // prefs, device
            },
            runMatchMakerFramework: {
                funcName: "gpii.request.flowManager.runMatchMakerFramework",
                args: [ "{that}", "{gpii.matchMakerFramework}",  "{arguments}.0", "{arguments}.1", "{arguments}.2"]
                                                               // prefs, device, solutionsRegistry
            },
            getSolutions: {
                funcName: "gpii.request.flowManager.getSolutions",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutionsRegistry"]
            },
            fireOnMatch: {
                funcName: "gpii.request.flowManager.fireOnMatch",
                args: [ "{that}.events.onMatch", "{arguments}" ]
            }
        },
        events: {
            onSolutionsRegistry: null,
            onDevice: null,
            onToken: null,
            onPreferences: null,
            onMatch: null,
            onReadyForLifecycle: null,
            onReadyToMatch: {
                events: {
                    preferences: "onPreferences",
                    device: "onDevice",
                    solutionsRegistry: "onSolutionsRegistry"
                },
                args: ["{arguments}.preferences.0", "{arguments}.device.0", "{arguments}.solutionsRegistry.0"]
            }
        },
        listeners: {
            onToken: "{that}.getPreferences",
            onReadyToMatch: "{that}.runMatchMakerFramework",
            onDevice: "{that}.getSolutions",
            "{gpii.matchMakerFramework}.events.onMatch": "{that}.fireOnMatch"
        }
    });

    fluid.defaults("gpii.request.flowManager.sessionAware", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            getActiveSessionTokens: {
                func: "{flowManager}.lifecycleManager.getActiveSessionTokens"
            },
            withSession: {
                funcName: "gpii.request.flowManager.sessionAware.withSession",
                args: ["{that}", "{flowManager}.lifecycleManager", "{requestProxy}.events", "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    //Somewhat hacky solution to http://issues.fluidproject.org/browse/FLUID-5546
    //Will "forward" the "onMatch" event from the MatchMakerFramework to the
    //"onMatch" event of the flowmanager
    gpii.request.flowManager.fireOnMatch = function (event, args) {
        event.fire.apply(null, args);
    };

    gpii.request.flowManager.sessionAware.withSession = function (that, lifecycleManager, events, callback, failMessage) {
        var tokens = that.getActiveSessionTokens();
        if (tokens.length === 0) {
            console.log("&&&&&&&&&&&&&&&&& FIRING SESSIONAWARE ONERROR FROM " + new Error().stack);
            console.log("Current request: " + util.inspect(kettle.getCurrentRequest()));
            failMessage = failMessage || "Error handling request which required active session, but none was active";
            events.onError.fire({
                isError: true,
                message: failMessage
            });
        } else {
            var session = lifecycleManager.getSession(tokens);
            callback(session, tokens);
        }
    };
})();
